### @name register
POST {{host}}/auth/register
Content-Type: application/json
Accept: application/json

{
  "email": "{{email}}",
  "password": "{{password}}",
  "displayName": "{{displayName}}"
}

> {%
    const TAG = "register";
    const pretty = v => { try { return typeof v === 'string' ? v : JSON.stringify(v, null, 2); } catch { return "[unserializable]"; } };
    const s = v => { try { return String(v); } catch { return "[unprintable]"; } };
    const bodyOf = (r) => typeof r.body === "object" ? r.body : (() => { try { return JSON.parse(r.body); } catch { return r.body; } })();

    client.log(`[${TAG}] ${s(request.method)} ${s(request.url)} -> ${s(response.status)} ${s(response.statusText)}`);
    client.log(`[${TAG}] request.body=${pretty(request.body)}`);

    const body = bodyOf(response);
    client.log(`[${TAG}] response.body=${pretty(body)}`);

    if (body && body.accessToken) {
        client.global.set("accessToken", body.accessToken);
        client.global.set("refreshToken", body.refreshToken || "");
        client.global.set("authHeader", `Bearer ${body.accessToken}`);
        client.global.set("displayName", body.displayName || "");
        if (typeof body.mfaEnabled === "boolean") client.global.set("mfaEnabled", String(body.mfaEnabled));
        const exp = Math.floor(Date.now()/1000) + (body.expiresInSeconds || 0);
        client.global.set("expiresAtEpoch", String(exp));
        client.log(`[${TAG}] saved tokens; mfaEnabled=${body.mfaEnabled ?? "n/a"}; expiresAtEpoch=${exp}`);
    } else {
        client.log(`[${TAG}] response missing tokens`);
    }
%}

### @name login_one_shot  (deprecated endpoint, still supported)
POST {{host}}/auth/login
Content-Type: application/json
Accept: application/json

{
  "emailOrUsername": "{{email}}",
  "password": "{{password}}",
  "mfaCode": "{{mfaCode}}"
}

> {%
    const TAG = "login(deprecated)";
    const pretty = v => { try { return typeof v === 'string' ? v : JSON.stringify(v, null, 2); } catch { return "[unserializable]"; } };
    const s = v => { try { return String(v); } catch { return "[unprintable]"; } };
    const bodyOf = (r) => typeof r.body === "object" ? r.body : (() => { try { return JSON.parse(r.body); } catch { return r.body; } })();

    client.log(`[${TAG}] ${s(request.method)} ${s(request.url)} -> ${s(response.status)} ${s(response.statusText)}`);
    client.log(`[${TAG}] request.body=${pretty(request.body)}`);

    const body = bodyOf(response);
    client.log(`[${TAG}] response.body=${pretty(body)}`);

    if (body && body.accessToken) {
        client.global.set("accessToken", body.accessToken);
        client.global.set("refreshToken", body.refreshToken || "");
        client.global.set("authHeader", `Bearer ${body.accessToken}`);
        client.global.set("displayName", body.displayName || "");
        if (typeof body.mfaEnabled === "boolean") client.global.set("mfaEnabled", String(body.mfaEnabled));
        const exp = Math.floor(Date.now()/1000) + (body.expiresInSeconds || 0);
        client.global.set("expiresAtEpoch", String(exp));
        client.log(`[${TAG}] saved tokens; mfaEnabled=${body.mfaEnabled ?? "n/a"}; expiresAtEpoch=${exp}`);
    } else if (body && body.loginTicket) {
        client.global.set("loginTicket", body.loginTicket);
        const factors = Array.isArray(body.allowedFactors) ? body.allowedFactors : [];
        client.global.set("allowedFactors", factors.join(","));
        client.log(`[${TAG}] saved loginTicket; allowedFactors=${factors.join(",")}`);
    } else {
        client.log(`[${TAG}] no tokens and no loginTicket found`);
    }
%}

### @name login_start  (two-step: start)
POST {{host}}/auth/login/start
Content-Type: application/json
Accept: application/json

{
  "emailOrUsername": "{{email}}",
  "password": "{{password}}"
}

> {%
    const TAG = "login/start";
    const pretty = v => { try { return typeof v === 'string' ? v : JSON.stringify(v, null, 2); } catch { return "[unserializable]"; } };
    const s = v => { try { return String(v); } catch { return "[unprintable]"; } };
    const bodyOf = (r) => typeof r.body === "object" ? r.body : (() => { try { return JSON.parse(r.body); } catch { return r.body; } })();

    client.log(`[${TAG}] ${s(request.method)} ${s(request.url)} -> ${s(response.status)} ${s(response.statusText)}`);
    client.log(`[${TAG}] request.body=${pretty(request.body)}`);

    const body = bodyOf(response);
    client.log(`[${TAG}] response.body=${pretty(body)}`);

    if (body && body.accessToken) {
        client.global.set("accessToken", body.accessToken);
        client.global.set("refreshToken", body.refreshToken || "");
        client.global.set("authHeader", `Bearer ${body.accessToken}`);
        client.global.set("displayName", body.displayName || "");
        if (typeof body.mfaEnabled === "boolean") client.global.set("mfaEnabled", String(body.mfaEnabled));
        const exp = Math.floor(Date.now()/1000) + (body.expiresInSeconds || 0);
        client.global.set("expiresAtEpoch", String(exp));
        client.log(`[${TAG}] saved tokens (no MFA required); expiresAtEpoch=${exp}`);
    } else if (body && body.loginTicket) {
        client.global.set("loginTicket", body.loginTicket);
        const factors = Array.isArray(body.allowedFactors) ? body.allowedFactors : [];
        client.global.set("allowedFactors", factors.join(","));
        client.log(`[${TAG}] saved loginTicket; allowedFactors=${factors.join(",")}`);
    } else {
        client.log(`[${TAG}] no tokens and no loginTicket found`);
    }
%}

### @name login_complete_totp  (two-step: complete)
POST {{host}}/auth/login/complete
Content-Type: application/json
Accept: application/json

{
  "loginTicket": "{{loginTicket}}",
  "factor": "TOTP",
  "code": "{{mfaCode}}"
}

> {%
    const TAG = "login/complete";
    const pretty = v => { try { return typeof v === 'string' ? v : JSON.stringify(v, null, 2); } catch { return "[unserializable]"; } };
    const s = v => { try { return String(v); } catch { return "[unprintable]"; } };
    const bodyOf = (r) => typeof r.body === "object" ? r.body : (() => { try { return JSON.parse(r.body); } catch { return r.body; } })();

    client.log(`[${TAG}] ${s(request.method)} ${s(request.url)} -> ${s(response.status)} ${s(response.statusText)}`);
    client.log(`[${TAG}] request.body=${pretty(request.body)}`);

    const body = bodyOf(response);
    client.log(`[${TAG}] response.body=${pretty(body)}`);

    if (body && body.accessToken) {
        client.global.set("accessToken", body.accessToken);
        client.global.set("refreshToken", body.refreshToken || "");
        client.global.set("authHeader", `Bearer ${body.accessToken}`);
        client.global.set("displayName", body.displayName || "");
        if (typeof body.mfaEnabled === "boolean") client.global.set("mfaEnabled", String(body.mfaEnabled));
        const exp = Math.floor(Date.now()/1000) + (body.expiresInSeconds || 0);
        client.global.set("expiresAtEpoch", String(exp));
        // Clear transient challenge vars
        client.global.set("loginTicket", "");
        client.global.set("allowedFactors", "");
        client.log(`[${TAG}] saved tokens; expiresAtEpoch=${exp}`);
    } else {
        client.log(`[${TAG}] response missing tokens`);
    }
%}

### @name refresh
POST {{host}}/auth/refresh
Content-Type: application/json
Accept: application/json

{
  "refreshToken": "{{refreshToken}}"
}

> {%
    const TAG = "refresh";
    const pretty = v => { try { return typeof v === 'string' ? v : JSON.stringify(v, null, 2); } catch { return "[unserializable]"; } };
    const s = v => { try { return String(v); } catch { return "[unprintable]"; } };
    const bodyOf = (r) => typeof r.body === "object" ? r.body : (() => { try { return JSON.parse(r.body); } catch { return r.body; } })();

    client.log(`[${TAG}] ${s(request.method)} ${s(request.url)} -> ${s(response.status)} ${s(response.statusText)}`);
    client.log(`[${TAG}] request.body=${pretty(request.body)}`);

    const body = bodyOf(response);
    client.log(`[${TAG}] response.body=${pretty(body)}`);

    if (body && body.accessToken) {
        client.global.set("accessToken", body.accessToken);
        client.global.set("refreshToken", body.refreshToken || "");
        client.global.set("authHeader", `Bearer ${body.accessToken}`);
        if (typeof body.mfaEnabled === "boolean") client.global.set("mfaEnabled", String(body.mfaEnabled));
        const exp = Math.floor(Date.now()/1000) + (body.expiresInSeconds || 0);
        client.global.set("expiresAtEpoch", String(exp));
        client.log(`[${TAG}] rotated tokens; expiresAtEpoch=${exp}`);
    } else {
        client.log(`[${TAG}] response missing tokens`);
    }
%}

### @name logout
POST {{host}}/auth/logout
Content-Type: application/json
Accept: application/json

{
  "refreshToken": "{{refreshToken}}"
}

> {%
    const TAG = "logout";
    const pretty = v => { try { return typeof v === 'string' ? v : JSON.stringify(v, null, 2); } catch { return "[unserializable]"; } };
    const s = v => { try { return String(v); } catch { return "[unprintable]"; } };

    client.log(`[${TAG}] ${s(request.method)} ${s(request.url)} -> ${s(response.status)} ${s(response.statusText)}`);
    client.log(`[${TAG}] request.body=${pretty(request.body)}`);

    // Clear only known keys (safer than clearAll if you store other globals)
    for (const k of ["accessToken","refreshToken","authHeader","expiresAtEpoch","displayName","mfaEnabled","loginTicket","allowedFactors"]) {
        client.global.set(k, "");
    }
    client.log(`[${TAG}] cleared auth globals`);
%}

### @name me  (example protected call)
GET {{host}}/me
Authorization: {{authHeader}}
Accept: application/json